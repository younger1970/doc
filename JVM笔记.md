jvm笔记

# 1.JVM的组成

![image-20220310165847916](E:\github-space\doc\jvm结构图.png)

JVM包含两个子系统和两个组件。

两个子系统：类加载子系统(Class loader)、执行引擎（execution engine）;

两个组件：运行时数据取（runtime data area）,本地接口（native interface）.

class loader：根据给定的全限定名类型（例如java.lang.class）来装在class文件到运行时数据区（runtime data area）,

execution engine:执行class文件中的指令

native interface：是与其他编程语言交互的接口。因为class文件最终需要转成更底层的指令来执行，更底层的指令会调用本地的方法库。

runtime data area：就是我们常说的jvm内存。

程序运行过程：

1.idea编译器吧java文件编译成class文件，类加载器（class loader）在把字节码文件加载到运行时数据区（runtime data area）

2.执行引擎将字节码文件翻译成底层系统指令，并交由cpu去执行。这个过程中，会调用native interface去实现部分功能。（ps:字节码文件只是jvm的一套指令集，并不能交由底层系统去执行,所以需要执行引擎执行指令翻译）。

# 2.jvm内存区域

java虚拟机在程序运行时，会把把管理的内存区域划分为若干个数据区域。每个区域有各自特定的用途、创建及销毁时间。有的区域会随着虚拟机进程的启动而存在，有的区域会依赖线程的启动和结束进行创建和销毁。具体划分区域如下：

![image-20220310172850026](E:\github-space\doc\jvm内存组成图.png)

1.程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器会通过改变这个计数值，来判断下一条需要执行的字节码指令，程序的循环、跳转、分支、异常处理、线程恢复等基础功能，都会依程序计数器。

2.虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（ps：我的理解是，更多的是用作方法栈，在程序被调用时，利用栈“先进后出”的原理，保证方法顺序执行）

3.本地方法栈：与虚拟机栈的作用是一致的。不同的虚拟机栈是为了虚拟机而服务的，本地方法栈是为了native interface所服务的。

4.java 堆（java heap）:java虚拟机内存中最大的一块，被所有线程所共享，几乎所有的对象实例都会在这里分配内存；

5.方法区：用于存储已被虚拟机所加载的类信息、常亮、静态变量、即时编译后的代码等数据。

# 3.深克隆和浅克隆

# 4.堆和栈的区别



1.物理地址不同：

堆的物理地址分配对象是不连续的，因此性能会慢一些。在垃圾回收时，也需要考虑到不连续造成的影响，所以才有各种各样的垃圾回收算法。例如，标记-清除，复制，标志-压缩，分代（即新生代使用复制算法，老年代使用标记-压缩）

栈使用的是数据结构中的栈。遵循“先进后出”的原则，物理地址分配是连续的，所以性能快。

2.内存分别：

堆因为是不连续的，所以分配的内存大小是需要在运行期来确认。一般堆大小，远远大于栈，且大小是不固定的。

栈是连续的，分配的内存大小，在编译期的时候就需要确认，大小是固定的

3.存放的内容：

堆存放的是对象的实例和数组，因此该区更关注的事数据的存储。

栈存放的局部变量、操作数栈、返回结果。该区更关注的是程序方法的执行。

ps:1.静态变量存放在方法区，静态类存放在堆中。

4.程序的可见度

堆是线程共享的，对于整个应用程序都是可见的；

栈是只对与线程可见，他的生命周期依赖于线程的生命周期。

# 5.hotspot虚拟机对象探秘

## 5.1对象的创建

java中提供的几种对象创建方式：

1.使用new

2.反射。使用class的newinstance（）

3.克隆。

4.反序列化

# 6.java内存泄露问题

内存泄露指不再使用的对象和变量一直占据在内存中，理论上来讲，java是有GC机制的，不应当发生内存泄露问题。但实际上，仍有内存泄露的问题发生。

发生的原因在于：长生命周期的对象，持有了短生命周期的引用。导致短生命周期的对象即使不被使用，但由于一直被长生命周期对象所持有，导致无法被gc回收。

解决办法:重启一次？调大内存？

# 7.垃圾收集器

## 7.1垃圾回收机制

在java中，程序员不用手动去释放对象的内存，虚拟机自动会帮我们释放。在jvm中，有一个垃圾回收线程，他是低优先级的。只有在jvm空闲或者内存不足时，才会启动，来扫描当前没有被任何地方引用的对象，并将它们添加到被需要被回收的集合中，然后进行回收。

垃圾回收机制的好处：

1.避免了人工释放对象内存（在java中，人工虽然可以手动调用system.gc（），但jvm不会立即执行该指令）

2.避免了内存泄露。（但java也会在低概率存在内存泄露）

# 8.java的引用类型

强引用：发生gc时不会被回收

软引用：有用但不是必须的对象，在发生内存溢出之前会被回收

弱引用：有用但不是必须的对象，在发生下一次gc时会被回收

虚拟引用：无法通过虚引用返回一个对象，他的用途是在gc时返回一个通知

不同引用类型的对象，在垃圾回收时，具有不同的优先级。

# 9.怎样判断对象是否可以被回收

gc时，需要判断哪些对象是可以被回收的，哪些对象是不可以被回收的。以下是两种判断方式：

1.引用计数器法：为每个对象创建一个引用计数器。当对象被引用时，计数器+1，当引用被释放时，计数器-1，当计数器为0时，表明可以被回收。缺点：当对象存在循环引用时，无法被回收。

2.可达性分析算法：从GC roots开始向下搜索，搜索所走过的路径成为引用链。当对象到gc roots,没有任何引用连相连的时候，证明这个对象是可以被回收的

# 10.几种常见的垃圾回收算法

9.1标记-清除算法



























